<?php

declare(strict_types=1);

/*
 * This file has been auto generated by Jane,
 *
 * Do no edit it directly.
 */

namespace Pezos\Generated\Rpc;

class Client extends Runtime\Client\Client
{
    /**
     * Forcefully set the bootstrapped flag of the node.
     *
     * @param string $chainId A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function patchChainByChainId(string $chainId, ?Model\ChainsChainIdPatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchChainByChainId($chainId, $requestBody), $fetch);
    }

    /**
     * Lists block hashes from '<chain>', up to the last checkpoint, sorted with decreasing fitness. Without arguments it returns the head of the chain. Optional arguments allow to return the list of predecessors of a given block or of a set of blocks.
     *
     * @param string $chainId         A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     * @param array  $queryParameters {
     *
     * @var string $length the requested number of predecessors to return (per request; see next argument)
     * @var string $head block_hash (Base58Check-encoded) An empty argument requests blocks starting with the current head. A non empty list allows to request one or more specific fragments of the chain.
     * @var string $min_date A date in seconds from epoch When `min_date` is provided, blocks with a timestamp before `min_date` are filtered out. However, if the `length` parameter is also provided, then up to that number of predecessors will be returned regardless of their date.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getChainsByChainIdBlocks(string $chainId, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetChainsByChainIdBlocks($chainId, $queryParameters), $fetch);
    }

    /**
     * The chain unique identifier.
     *
     * @param string $chainId A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getChainsByChainIdChainId(string $chainId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetChainsByChainIdChainId($chainId), $fetch);
    }

    /**
     * Lists blocks that have been declared invalid along with the errors that led to them being declared invalid.
     *
     * @param string $chainId A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ChainsChainIdInvalidBlocksGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getChainsByChainIdInvalidBlocks(string $chainId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetChainsByChainIdInvalidBlocks($chainId), $fetch);
    }

    /**
     * Remove an invalid block for the tezos storage.
     *
     * @param string $chainId   A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     * @param string $blockHash block_hash (Base58Check-encoded)
     * @param string $fetch     Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ChainsChainIdInvalidBlocksBlockHashDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function deleteChainsByChainIdInvalidBlockByBlockHash(string $chainId, string $blockHash, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteChainsByChainIdInvalidBlockByBlockHash($chainId, $blockHash), $fetch);
    }

    /**
     * The errors that appears during the block (in)validation.
     *
     * @param string $chainId   A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     * @param string $blockHash block_hash (Base58Check-encoded)
     * @param string $fetch     Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ChainsChainIdInvalidBlocksBlockHashGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getChainsByChainIdInvalidBlockByBlockHash(string $chainId, string $blockHash, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetChainsByChainIdInvalidBlockByBlockHash($chainId, $blockHash), $fetch);
    }

    /**
     * The bootstrap status of a chain.
     *
     * @param string $chainId A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ChainsChainIdIsBootstrappedGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getChainsByChainIdIsBootstrapped(string $chainId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetChainsByChainIdIsBootstrapped($chainId), $fetch);
    }

    /**
     * The current caboose for this chain.
     *
     * @param string $chainId A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ChainsChainIdLevelsCabooseGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getChainsByChainIdLevelsCaboose(string $chainId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetChainsByChainIdLevelsCaboose($chainId), $fetch);
    }

    /**
     * The current checkpoint for this chain.
     *
     * @param string $chainId A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ChainsChainIdLevelsCheckpointGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getChainsByChainIdLevelsCheckpoint(string $chainId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetChainsByChainIdLevelsCheckpoint($chainId), $fetch);
    }

    /**
     * The current savepoint for this chain.
     *
     * @param string $chainId A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ChainsChainIdLevelsSavepointGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getChainsByChainIdLevelsSavepoint(string $chainId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetChainsByChainIdLevelsSavepoint($chainId), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ConfigGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getConfig(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetConfig(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ConfigHistoryModeGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getConfigHistoryMode(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetConfigHistoryMode(), $fetch);
    }

    /**
     * Replace the logging configuration of the node.
     *
     * @param mixed|null $requestBody
     * @param string     $fetch       Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ConfigLoggingPutResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function putConfigLogging($requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PutConfigLogging($requestBody), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ConfigNetworkDalGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getConfigNetworkDal(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetConfigNetworkDal(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ConfigNetworkUserActivatedProtocolOverridesGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getConfigNetworkUserActivatedProtocolOverrides(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetConfigNetworkUserActivatedProtocolOverrides(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ConfigNetworkUserActivatedUpgradesGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getConfigNetworkUserActivatedUpgrades(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetConfigNetworkUserActivatedUpgrades(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getError(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetError(), $fetch);
    }

    /**
     * Fetch a protocol from the network.
     *
     * @param string $protocolHash Protocol_hash (Base58Check-encoded)
     * @param string $fetch        Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getFetchProtocolByProtocolHash(string $protocolHash, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetFetchProtocolByProtocolHash($protocolHash), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HealthReadyGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getHealthReady(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetHealthReady(), $fetch);
    }

    /**
     * Inject a block in the node and broadcast it. The `operations` embedded in `blockHeader` might be pre-validated using a contextual RPCs from the latest block (e.g. '/blocks/head/context/preapply'). Returns the ID of the block. By default, the RPC will wait for the block to be validated before answering. If ?async is true, the function returns immediately. Otherwise, the block will be validated before the result is returned. If ?force is true, it will be injected even on non strictly increasing fitness. An optional ?chain parameter can be used to specify whether to inject on the test chain or the main chain.
     *
     * @param array $queryParameters {
     *
     * @var string $async
     * @var string $force
     * @var string $chain A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postInjectionBlock(?Model\InjectionBlockPostBody $requestBody = null, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostInjectionBlock($requestBody, $queryParameters), $fetch);
    }

    /**
     * Inject an operation in node and broadcast it. Returns the ID of the operation. The `signedOperationContents` should be constructed using contextual RPCs from the latest block and signed by the client. The injection of the operation will apply it on the current mempool context. This context may change at each operation injection or operation reception from peers. By default, the RPC will wait for the operation to be (pre-)validated before returning. However, if ?async is true, the function returns immediately. The optional ?chain parameter can be used to specify whether to inject on the test chain or the main chain.
     *
     * @param array $queryParameters {
     *
     * @var string $async
     * @var string $chain A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postInjectionOperation(?string $requestBody = null, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostInjectionOperation($requestBody, $queryParameters), $fetch);
    }

    /**
     * Inject a protocol in node. Returns the ID of the protocol. If ?async is true, the function returns immediately. Otherwise, the protocol will be validated before the result is returned.
     *
     * @param array $queryParameters {
     *
     * @var string $async
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postInjectionProtocol(?Model\InjectionProtocolPostBody $requestBody = null, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostInjectionProtocol($requestBody, $queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getMonitorActiveChains(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetMonitorActiveChains(), $fetch);
    }

    /**
     * Monitor all blocks that are successfully applied and stored by the node, disregarding whether they were selected as the new head or not.
     *
     * @param array $queryParameters {
     *
     * @var string $protocol Protocol_hash (Base58Check-encoded)
     * @var string $next_protocol Protocol_hash (Base58Check-encoded)
     * @var string $chain A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\MonitorAppliedBlocksGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getMonitorAppliedBlock(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetMonitorAppliedBlock($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\MonitorBootstrappedGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getMonitorBootstrapped(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetMonitorBootstrapped(), $fetch);
    }

    /**
     * Monitor all blocks that are successfully validated and applied by the node and selected as the new head of the given chain.
     *
     * @param string $chainId         A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     * @param array  $queryParameters {
     *
     * @var string $protocol Protocol_hash (Base58Check-encoded)
     * @var string $next_protocol Protocol_hash (Base58Check-encoded)
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\MonitorHeadsChainIdGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getMonitorHeadByChainId(string $chainId, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetMonitorHeadByChainId($chainId, $queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getMonitorProtocol(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetMonitorProtocol(), $fetch);
    }

    /**
     * Monitor all blocks that were successfully validated by the node but are not applied nor stored yet, disregarding whether they are going to be selected as the new head or not.
     *
     * @param array $queryParameters {
     *
     * @var string $protocol Protocol_hash (Base58Check-encoded)
     * @var string $next_protocol Protocol_hash (Base58Check-encoded)
     * @var string $chain A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\MonitorValidatedBlocksGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getMonitorValidatedBlock(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetMonitorValidatedBlock($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\NetworkConnectionsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getNetworkConnections(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetNetworkConnections(), $fetch);
    }

    /**
     * Forced close of the current P2P connection to the given peer.
     *
     * @param string $peerId          A cryptographic node identity (Base58Check-encoded)
     * @param array  $queryParameters {
     *
     * @var string $wait
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\NetworkConnectionsPeerIdDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function deleteNetworkConnectionByPeerId(string $peerId, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteNetworkConnectionByPeerId($peerId, $queryParameters), $fetch);
    }

    /**
     * Details about the current P2P connection to the given peer.
     *
     * @param string $peerId A cryptographic node identity (Base58Check-encoded)
     * @param string $fetch  Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\NetworkConnectionsPeerIdGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getNetworkConnectionByPeerId(string $peerId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetNetworkConnectionByPeerId($peerId), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\NetworkGreylistDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function deleteNetworkGreylist(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteNetworkGreylist(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\NetworkGreylistIpsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getNetworkGreylistIp(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetNetworkGreylistIp(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getNetworkGreylistPeers(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetNetworkGreylistPeers(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getNetworkLog(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetNetworkLog(), $fetch);
    }

    /**
     * List the peers the node ever met.
     *
     * @param array $queryParameters {
     *
     * @var string $filter
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getNetworkPeers(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetNetworkPeers($queryParameters), $fetch);
    }

    /**
     * Details about a given peer.
     *
     * @param string $peerId A cryptographic node identity (Base58Check-encoded)
     * @param string $fetch  Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\NetworkPeersPeerIdGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getNetworkPeerByPeerId(string $peerId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetNetworkPeerByPeerId($peerId), $fetch);
    }

    /**
     * Change the permissions of a given peer. With `{acl: ban}`: blacklist the given peer and remove it from the whitelist if present. With `{acl: open}`: removes the peer from the blacklist and whitelist. With `{acl: trust}`: trust the given peer permanently and remove it from the blacklist if present. The peer cannot be blocked (but its host IP still can).
     *
     * @param string $peerId A cryptographic node identity (Base58Check-encoded)
     * @param string $fetch  Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\NetworkPeersPeerIdPatchResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function patchNetworkPeerByPeerId(string $peerId, ?Model\NetworkPeersPeerIdPatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchNetworkPeerByPeerId($peerId, $requestBody), $fetch);
    }

    /**
     * Check if a given peer is blacklisted or greylisted.
     *
     * @param string $peerId A cryptographic node identity (Base58Check-encoded)
     * @param string $fetch  Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getNetworkPeersByPeerIdBanned(string $peerId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetNetworkPeersByPeerIdBanned($peerId), $fetch);
    }

    /**
     * Monitor network events related to a given peer.
     *
     * @param string $peerId          A cryptographic node identity (Base58Check-encoded)
     * @param array  $queryParameters {
     *
     * @var string $monitor
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pPeerPoolEvent[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getNetworkPeersByPeerIdLog(string $peerId, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetNetworkPeersByPeerIdLog($peerId, $queryParameters), $fetch);
    }

    /**
     * List the pool of known `IP:port` used for establishing P2P connections.
     *
     * @param array $queryParameters {
     *
     * @var string $filter
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getNetworkPoints(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetNetworkPoints($queryParameters), $fetch);
    }

    /**
     * Details about a given `IP:addr`.
     *
     * @param string $point a network point (ipv4:port or [ipv6]:port)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\NetworkPointsPointGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getNetworkPointByPoint(string $point, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetNetworkPointByPoint($point), $fetch);
    }

    /**
     * Change the connectivity state of a given `IP:addr`. With `{acl : ban}`: blacklist the given address and remove it from the whitelist if present. With `{acl: open}`: removes an address from the blacklist and whitelist. With `{acl: trust}`: trust a given address permanently and remove it from the blacklist if present. With `{peer_id: <id>}` set the peerId of the point. Connections from this address can still be closed on authentication if the peer is greylisted.
     *
     * @param string $point a network point (ipv4:port or [ipv6]:port)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\NetworkPointsPointPatchResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function patchNetworkPointByPoint(string $point, ?Model\NetworkPointsPointPatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchNetworkPointByPoint($point, $requestBody), $fetch);
    }

    /**
     * Connect to a peer.
     *
     * @param string $point           a network point (ipv4:port or [ipv6]:port)
     * @param array  $queryParameters {
     *
     * @var string $timeout A span of time in seconds
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\NetworkPointsPointPutResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function putNetworkPointByPoint(string $point, ?Model\NetworkPointsPointPutBody $requestBody = null, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PutNetworkPointByPoint($point, $requestBody, $queryParameters), $fetch);
    }

    /**
     * Check if a given address is blacklisted or greylisted. Port component is unused.
     *
     * @param string $point a network point (ipv4:port or [ipv6]:port)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getNetworkPointsByPointBanned(string $point, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetNetworkPointsByPointBanned($point), $fetch);
    }

    /**
     * Monitor network events related to an `IP:addr`.
     *
     * @param string $point           a network point (ipv4:port or [ipv6]:port)
     * @param array  $queryParameters {
     *
     * @var string $monitor
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getNetworkPointsByPointLog(string $point, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetNetworkPointsByPointLog($point, $queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getNetworkSelf(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetNetworkSelf(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\NetworkStatGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getNetworkStat(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetNetworkStat(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getProtocols(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetProtocols(), $fetch);
    }

    /**
     * (no description).
     *
     * @param string $protocolHash Protocol_hash (Base58Check-encoded)
     * @param string $fetch        Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ProtocolsProtocolHashGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getProtocolByProtocolHash(string $protocolHash, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetProtocolByProtocolHash($protocolHash), $fetch);
    }

    /**
     * (no description).
     *
     * @param string $protocolHash Protocol_hash (Base58Check-encoded)
     * @param string $fetch        Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getProtocolsByProtocolHashEnvironment(string $protocolHash, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetProtocolsByProtocolHashEnvironment($protocolHash), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\StatsGcGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getStatsGc(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetStatsGc(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getStatsMemory(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetStatsMemory(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VersionGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getVersion(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVersion(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\WorkersBlockValidatorGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getWorkersBlockValidator(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetWorkersBlockValidator(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\WorkersChainValidatorsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getWorkersChainValidators(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetWorkersChainValidators(), $fetch);
    }

    /**
     * Introspect the state of a chain validator worker.
     *
     * @param string $chainId A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\WorkersChainValidatorsChainIdGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getWorkersChainValidatorByChainId(string $chainId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetWorkersChainValidatorByChainId($chainId), $fetch);
    }

    /**
     * Introspect the state of the DDB attached to a chain validator worker.
     *
     * @param string $chainId A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\WorkersChainValidatorsChainIdDdbGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getWorkersChainValidatorsByChainIdDdb(string $chainId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetWorkersChainValidatorsByChainIdDdb($chainId), $fetch);
    }

    /**
     * Lists the peer validator workers and their status.
     *
     * @param string $chainId A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\WorkersChainValidatorsChainIdPeersValidatorsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getWorkersChainValidatorsByChainIdPeersValidators(string $chainId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetWorkersChainValidatorsByChainIdPeersValidators($chainId), $fetch);
    }

    /**
     * Introspect the state of a peer validator worker.
     *
     * @param string $chainId A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     * @param string $peerId  A cryptographic node identity (Base58Check-encoded)
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\WorkersChainValidatorsChainIdPeersValidatorsPeerIdGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getWorkersChainValidatorsByChainIdPeersValidatorByPeerId(string $chainId, string $peerId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetWorkersChainValidatorsByChainIdPeersValidatorByPeerId($chainId, $peerId), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\WorkersPrevalidatorsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getWorkersPrevalidators(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetWorkersPrevalidators(), $fetch);
    }

    /**
     * Introspect the state of prevalidator workers.
     *
     * @param string $chainId A chain identifier. This is either a chain hash in Base58Check notation or a one the predefined aliases: 'main', 'test'.
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\WorkersPrevalidatorsChainIdGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getWorkersPrevalidatorByChainId(string $chainId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetWorkersPrevalidatorByChainId($chainId), $fetch);
    }

    public static function create($httpClient = null, array $additionalPlugins = [], array $additionalNormalizers = [])
    {
        if (null === $httpClient) {
            $httpClient = \Http\Discovery\Psr18ClientDiscovery::find();
            $plugins = [];
            if (count($additionalPlugins) > 0) {
                $plugins = array_merge($plugins, $additionalPlugins);
            }
            $httpClient = new \Http\Client\Common\PluginClient($httpClient, $plugins);
        }
        $requestFactory = \Http\Discovery\Psr17FactoryDiscovery::findRequestFactory();
        $streamFactory = \Http\Discovery\Psr17FactoryDiscovery::findStreamFactory();
        $normalizers = [new \Symfony\Component\Serializer\Normalizer\ArrayDenormalizer(), new Normalizer\JaneObjectNormalizer()];
        if (count($additionalNormalizers) > 0) {
            $normalizers = array_merge($normalizers, $additionalNormalizers);
        }
        $serializer = new \Symfony\Component\Serializer\Serializer($normalizers, [new \Symfony\Component\Serializer\Encoder\JsonEncoder(new \Symfony\Component\Serializer\Encoder\JsonEncode(), new \Symfony\Component\Serializer\Encoder\JsonDecode(['json_decode_associative' => true]))]);

        return new static($httpClient, $requestFactory, $serializer, $streamFactory);
    }
}
