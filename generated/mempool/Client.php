<?php

declare(strict_types=1);

/*
 * This file has been auto generated by Jane,
 *
 * Do no edit it directly.
 */

namespace Pezos\Generated\Mempool;

class Client extends Runtime\Client\Client
{
    /**
     * Remove an operation from the mempool if present. Also add it to the set of banned operations to prevent it from being fetched/processed/injected in the future. Note: If the baker has already received the operation, then it's necessary to restart it to flush the operation from it.
     *
     * @param mixed|null $requestBody
     * @param string     $fetch       Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postBanOperation($requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostBanOperation($requestBody), $fetch);
    }

    /**
     * Get the configuration of the mempool's filter and bounds. Values of the form [ "21", "20" ] are rational numbers given as a numerator and a denominator, e.g. 21/20 = 1.05. The minimal_fees (in mutez), minimal_nanotez_per_gas_unit, and minimal_nanotez_per_byte are requirements that a manager operation must meet to be considered by the mempool. replace_by_fee_factor is how much better a manager operation must be to replace a previous valid operation **from the same manager** (both its fee and its fee/gas ratio must exceed the old operation's by at least this factor). max_operations and max_total_bytes are the bounds on respectively the number of valid operations in the mempool and the sum of their sizes in bytes.
     *
     * @param array $queryParameters {
     *
     * @var string $include_default Show fields equal to their default value (set by default)
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getFilter(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetFilter($queryParameters), $fetch);
    }

    /**
     * Set the configuration of the mempool's filter and bounds. **If any of the fields is absent from the input JSON, then it is set to the default value for this field (i.e. its value in the default configuration), even if it previously had a different value.** If the input JSON does not describe a valid configuration, then the configuration is left unchanged. This RPC also returns the new configuration of the mempool (which may differ from the input if the latter omits fields or is invalid). You may call [octez-client rpc get '/chains/main/mempool/filter?include_default=true'] to see an example of JSON describing a valid configuration. See the description of that RPC for details on each configurable value.
     *
     * @param mixed|null $requestBody
     * @param string     $fetch       Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postFilter($requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostFilter($requestBody), $fetch);
    }

    /**
     * Monitor the mempool operations.
     *
     * @param array $queryParameters {
     *
     * @var string $version Supported RPC versions are version "1" (default)
     * @var string $validated Include validated operations (set by default)
     * @var string $refused Include refused operations
     * @var string $outdated Include outdated operations
     * @var string $branch_refused Include branch refused operations
     * @var string $branch_delayed Include branch delayed operations (set by default)
     * @var string $validation_pass Include operations filtered by validation pass (all by default)
     * @var string $sources Include operations filtered by sources (all by default)
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\MonitorOperationsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getMonitorOperations(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetMonitorOperations($queryParameters), $fetch);
    }

    /**
     * List the prevalidated operations.
     *
     * @param array $queryParameters {
     *
     * @var string $version Supported RPC versions are version "2" (default)
     * @var string $validated Include validated operations (true by default)
     * @var string $refused Include refused operations (true by default)
     * @var string $outdated Include outdated operations (true by default)
     * @var string $branch_refused Include branch refused operations (true by default)
     * @var string $branch_delayed Include branch delayed operations (true by default)
     * @var string $validation_pass Include operations filtered by validation pass (all by default)
     * @var string $source Include operations filtered by source (all by default)
     * @var string $operation_hash Include operations filtered by hash (all by default)
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\PendingOperationsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getPendingOperation(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetPendingOperation($queryParameters), $fetch);
    }

    /**
     * Request the operations of our peers or a specific peer if specified via a query parameter.
     *
     * @param array $queryParameters {
     *
     * @var string $peer_id A cryptographic node identity (Base58Check-encoded)
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\RequestOperationsPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postRequestOperation(?Model\RequestOperationsPostBody $requestBody = null, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostRequestOperation($requestBody, $queryParameters), $fetch);
    }

    /**
     * Clear the set of banned operations.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postUnbanAllOperation(?Model\UnbanAllOperationsPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostUnbanAllOperation($requestBody), $fetch);
    }

    /**
     * Remove an operation from the set of banned operations (nothing happens if it was not banned).
     *
     * @param mixed|null $requestBody
     * @param string     $fetch       Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postUnbanOperation($requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostUnbanOperation($requestBody), $fetch);
    }

    public static function create($httpClient = null, array $additionalPlugins = [], array $additionalNormalizers = [])
    {
        if (null === $httpClient) {
            $httpClient = \Http\Discovery\Psr18ClientDiscovery::find();
            $plugins = [];
            if (count($additionalPlugins) > 0) {
                $plugins = array_merge($plugins, $additionalPlugins);
            }
            $httpClient = new \Http\Client\Common\PluginClient($httpClient, $plugins);
        }
        $requestFactory = \Http\Discovery\Psr17FactoryDiscovery::findRequestFactory();
        $streamFactory = \Http\Discovery\Psr17FactoryDiscovery::findStreamFactory();
        $normalizers = [new \Symfony\Component\Serializer\Normalizer\ArrayDenormalizer(), new Normalizer\JaneObjectNormalizer()];
        if (count($additionalNormalizers) > 0) {
            $normalizers = array_merge($normalizers, $additionalNormalizers);
        }
        $serializer = new \Symfony\Component\Serializer\Serializer($normalizers, [new \Symfony\Component\Serializer\Encoder\JsonEncoder(new \Symfony\Component\Serializer\Encoder\JsonEncode(), new \Symfony\Component\Serializer\Encoder\JsonDecode(['json_decode_associative' => true]))]);

        return new static($httpClient, $requestFactory, $serializer, $streamFactory);
    }
}
