<?php

declare(strict_types=1);

/*
 * This file has been auto generated by Jane,
 *
 * Do no edit it directly.
 */

namespace Pezos\Generated\Rollup\Model;

class ConfigGetResponse200 extends \ArrayObject
{
    /**
     * @var array
     */
    protected $initialized = [];

    public function isInitialized($property): bool
    {
        return array_key_exists($property, $this->initialized);
    }
    /**
     * Smart rollup address.
     */
    protected $smartRollupAddress;
    /**
     * Boot sector.
     */
    protected $bootSector;
    /**
     * Operators that sign operations of the smart rollup, by purpose.
     *
     * @var ConfigGetResponse200SmartRollupNodeOperator
     */
    protected $smartRollupNodeOperator;
    /**
     * RPC address.
     */
    protected $rpcAddr;
    /**
     * RPC port.
     *
     * @var int
     */
    protected $rpcPort;
    /**
     * Access control list.
     *
     * @var list<mixed>
     */
    protected $acl;
    /**
     * Metrics address.
     */
    protected $metricsAddr;
    /**
     * @var bool
     */
    protected $performanceMetrics;
    /**
     * The reconnection (to the tezos node) delay in seconds.
     *
     * @var float
     */
    protected $reconnectionDelay;
    /**
     * The fee parameters for each purpose used when injecting operations in L1.
     *
     * @var ConfigGetResponse200FeeParameters
     */
    protected $feeParameters;
    /**
     * The mode for this rollup node.
     */
    protected $mode;
    /**
     * If enabled, the rollup node will issue wrong commitments (for test only!).
     *
     * @var list<ConfigGetResponse200LoserModeItem>
     */
    protected $loserMode;
    /**
     * Unsafe patches to apply to the PVM. For tests only, don't set this value in production.
     *
     * @var list<mixed>
     */
    protected $unsafePvmPatches;
    /**
     * A filter to select which outbox messages the rollup will execute automatically (must be in maintenance or operator mode).
     *
     * @var list<ConfigGetResponse200ExecuteOutboxMessagesFilterItem>
     */
    protected $executeOutboxMessagesFilter;
    /**
     * Either a plain UTF8 string, or a sequence of bytes for strings that contain invalid byte sequences.
     */
    protected $dALNodeEndpoint;
    /**
     * Either a plain UTF8 string, or a sequence of bytes for strings that contain invalid byte sequences.
     */
    protected $dacObserverClient;
    /**
     * Decimal representation of a big number.
     *
     * @var string
     */
    protected $dacTimeout;
    /**
     * Either a plain UTF8 string, or a sequence of bytes for strings that contain invalid byte sequences.
     */
    protected $preImagesEndpoint;
    /**
     * @var ConfigGetResponse200Batcher
     */
    protected $batcher;
    /**
     * @var ConfigGetResponse200Injector
     */
    protected $injector;
    /**
     * @var int
     */
    protected $l1BlocksCacheSize;
    /**
     * @var int
     */
    protected $l2BlocksCacheSize;
    /**
     * @var int
     */
    protected $prefetchBlocks;
    /**
     * @var float
     */
    protected $l1RpcTimeout;
    /**
     * @var float
     */
    protected $loopRetryDelay;
    /**
     * Deprecated.
     *
     * @var int
     */
    protected $indexBufferSize;
    /**
     * @var int
     */
    protected $irminCacheSize;
    /**
     * @var bool
     */
    protected $logKernelDebug;
    /**
     * @var bool
     */
    protected $noDegraded;
    /**
     * @var ConfigGetResponse200GcParameters
     */
    protected $gcParameters;
    /**
     * @var string
     */
    protected $historyMode;
    /**
     * @var ConfigGetResponse200Cors
     */
    protected $cors;
    /**
     * @var bool
     */
    protected $bailOnDisagree;

    /**
     * Smart rollup address.
     */
    public function getSmartRollupAddress()
    {
        return $this->smartRollupAddress;
    }

    /**
     * Smart rollup address.
     */
    public function setSmartRollupAddress($smartRollupAddress): self
    {
        $this->initialized['smartRollupAddress'] = true;
        $this->smartRollupAddress = $smartRollupAddress;

        return $this;
    }

    /**
     * Boot sector.
     */
    public function getBootSector()
    {
        return $this->bootSector;
    }

    /**
     * Boot sector.
     */
    public function setBootSector($bootSector): self
    {
        $this->initialized['bootSector'] = true;
        $this->bootSector = $bootSector;

        return $this;
    }

    /**
     * Operators that sign operations of the smart rollup, by purpose.
     */
    public function getSmartRollupNodeOperator(): ConfigGetResponse200SmartRollupNodeOperator
    {
        return $this->smartRollupNodeOperator;
    }

    /**
     * Operators that sign operations of the smart rollup, by purpose.
     */
    public function setSmartRollupNodeOperator(ConfigGetResponse200SmartRollupNodeOperator $smartRollupNodeOperator): self
    {
        $this->initialized['smartRollupNodeOperator'] = true;
        $this->smartRollupNodeOperator = $smartRollupNodeOperator;

        return $this;
    }

    /**
     * RPC address.
     */
    public function getRpcAddr()
    {
        return $this->rpcAddr;
    }

    /**
     * RPC address.
     */
    public function setRpcAddr($rpcAddr): self
    {
        $this->initialized['rpcAddr'] = true;
        $this->rpcAddr = $rpcAddr;

        return $this;
    }

    /**
     * RPC port.
     */
    public function getRpcPort(): int
    {
        return $this->rpcPort;
    }

    /**
     * RPC port.
     */
    public function setRpcPort(int $rpcPort): self
    {
        $this->initialized['rpcPort'] = true;
        $this->rpcPort = $rpcPort;

        return $this;
    }

    /**
     * Access control list.
     *
     * @return list<mixed>
     */
    public function getAcl(): array
    {
        return $this->acl;
    }

    /**
     * Access control list.
     *
     * @param list<mixed> $acl
     */
    public function setAcl(array $acl): self
    {
        $this->initialized['acl'] = true;
        $this->acl = $acl;

        return $this;
    }

    /**
     * Metrics address.
     */
    public function getMetricsAddr()
    {
        return $this->metricsAddr;
    }

    /**
     * Metrics address.
     */
    public function setMetricsAddr($metricsAddr): self
    {
        $this->initialized['metricsAddr'] = true;
        $this->metricsAddr = $metricsAddr;

        return $this;
    }

    public function getPerformanceMetrics(): bool
    {
        return $this->performanceMetrics;
    }

    public function setPerformanceMetrics(bool $performanceMetrics): self
    {
        $this->initialized['performanceMetrics'] = true;
        $this->performanceMetrics = $performanceMetrics;

        return $this;
    }

    /**
     * The reconnection (to the tezos node) delay in seconds.
     */
    public function getReconnectionDelay(): float
    {
        return $this->reconnectionDelay;
    }

    /**
     * The reconnection (to the tezos node) delay in seconds.
     */
    public function setReconnectionDelay(float $reconnectionDelay): self
    {
        $this->initialized['reconnectionDelay'] = true;
        $this->reconnectionDelay = $reconnectionDelay;

        return $this;
    }

    /**
     * The fee parameters for each purpose used when injecting operations in L1.
     */
    public function getFeeParameters(): ConfigGetResponse200FeeParameters
    {
        return $this->feeParameters;
    }

    /**
     * The fee parameters for each purpose used when injecting operations in L1.
     */
    public function setFeeParameters(ConfigGetResponse200FeeParameters $feeParameters): self
    {
        $this->initialized['feeParameters'] = true;
        $this->feeParameters = $feeParameters;

        return $this;
    }

    /**
     * The mode for this rollup node.
     */
    public function getMode()
    {
        return $this->mode;
    }

    /**
     * The mode for this rollup node.
     */
    public function setMode($mode): self
    {
        $this->initialized['mode'] = true;
        $this->mode = $mode;

        return $this;
    }

    /**
     * If enabled, the rollup node will issue wrong commitments (for test only!).
     *
     * @return list<ConfigGetResponse200LoserModeItem>
     */
    public function getLoserMode(): array
    {
        return $this->loserMode;
    }

    /**
     * If enabled, the rollup node will issue wrong commitments (for test only!).
     *
     * @param list<ConfigGetResponse200LoserModeItem> $loserMode
     */
    public function setLoserMode(array $loserMode): self
    {
        $this->initialized['loserMode'] = true;
        $this->loserMode = $loserMode;

        return $this;
    }

    /**
     * Unsafe patches to apply to the PVM. For tests only, don't set this value in production.
     *
     * @return list<mixed>
     */
    public function getUnsafePvmPatches(): array
    {
        return $this->unsafePvmPatches;
    }

    /**
     * Unsafe patches to apply to the PVM. For tests only, don't set this value in production.
     *
     * @param list<mixed> $unsafePvmPatches
     */
    public function setUnsafePvmPatches(array $unsafePvmPatches): self
    {
        $this->initialized['unsafePvmPatches'] = true;
        $this->unsafePvmPatches = $unsafePvmPatches;

        return $this;
    }

    /**
     * A filter to select which outbox messages the rollup will execute automatically (must be in maintenance or operator mode).
     *
     * @return list<ConfigGetResponse200ExecuteOutboxMessagesFilterItem>
     */
    public function getExecuteOutboxMessagesFilter(): array
    {
        return $this->executeOutboxMessagesFilter;
    }

    /**
     * A filter to select which outbox messages the rollup will execute automatically (must be in maintenance or operator mode).
     *
     * @param list<ConfigGetResponse200ExecuteOutboxMessagesFilterItem> $executeOutboxMessagesFilter
     */
    public function setExecuteOutboxMessagesFilter(array $executeOutboxMessagesFilter): self
    {
        $this->initialized['executeOutboxMessagesFilter'] = true;
        $this->executeOutboxMessagesFilter = $executeOutboxMessagesFilter;

        return $this;
    }

    /**
     * Either a plain UTF8 string, or a sequence of bytes for strings that contain invalid byte sequences.
     */
    public function getDALNodeEndpoint()
    {
        return $this->dALNodeEndpoint;
    }

    /**
     * Either a plain UTF8 string, or a sequence of bytes for strings that contain invalid byte sequences.
     */
    public function setDALNodeEndpoint($dALNodeEndpoint): self
    {
        $this->initialized['dALNodeEndpoint'] = true;
        $this->dALNodeEndpoint = $dALNodeEndpoint;

        return $this;
    }

    /**
     * Either a plain UTF8 string, or a sequence of bytes for strings that contain invalid byte sequences.
     */
    public function getDacObserverClient()
    {
        return $this->dacObserverClient;
    }

    /**
     * Either a plain UTF8 string, or a sequence of bytes for strings that contain invalid byte sequences.
     */
    public function setDacObserverClient($dacObserverClient): self
    {
        $this->initialized['dacObserverClient'] = true;
        $this->dacObserverClient = $dacObserverClient;

        return $this;
    }

    /**
     * Decimal representation of a big number.
     */
    public function getDacTimeout(): string
    {
        return $this->dacTimeout;
    }

    /**
     * Decimal representation of a big number.
     */
    public function setDacTimeout(string $dacTimeout): self
    {
        $this->initialized['dacTimeout'] = true;
        $this->dacTimeout = $dacTimeout;

        return $this;
    }

    /**
     * Either a plain UTF8 string, or a sequence of bytes for strings that contain invalid byte sequences.
     */
    public function getPreImagesEndpoint()
    {
        return $this->preImagesEndpoint;
    }

    /**
     * Either a plain UTF8 string, or a sequence of bytes for strings that contain invalid byte sequences.
     */
    public function setPreImagesEndpoint($preImagesEndpoint): self
    {
        $this->initialized['preImagesEndpoint'] = true;
        $this->preImagesEndpoint = $preImagesEndpoint;

        return $this;
    }

    public function getBatcher(): ConfigGetResponse200Batcher
    {
        return $this->batcher;
    }

    public function setBatcher(ConfigGetResponse200Batcher $batcher): self
    {
        $this->initialized['batcher'] = true;
        $this->batcher = $batcher;

        return $this;
    }

    public function getInjector(): ConfigGetResponse200Injector
    {
        return $this->injector;
    }

    public function setInjector(ConfigGetResponse200Injector $injector): self
    {
        $this->initialized['injector'] = true;
        $this->injector = $injector;

        return $this;
    }

    public function getL1BlocksCacheSize(): int
    {
        return $this->l1BlocksCacheSize;
    }

    public function setL1BlocksCacheSize(int $l1BlocksCacheSize): self
    {
        $this->initialized['l1BlocksCacheSize'] = true;
        $this->l1BlocksCacheSize = $l1BlocksCacheSize;

        return $this;
    }

    public function getL2BlocksCacheSize(): int
    {
        return $this->l2BlocksCacheSize;
    }

    public function setL2BlocksCacheSize(int $l2BlocksCacheSize): self
    {
        $this->initialized['l2BlocksCacheSize'] = true;
        $this->l2BlocksCacheSize = $l2BlocksCacheSize;

        return $this;
    }

    public function getPrefetchBlocks(): int
    {
        return $this->prefetchBlocks;
    }

    public function setPrefetchBlocks(int $prefetchBlocks): self
    {
        $this->initialized['prefetchBlocks'] = true;
        $this->prefetchBlocks = $prefetchBlocks;

        return $this;
    }

    public function getL1RpcTimeout(): float
    {
        return $this->l1RpcTimeout;
    }

    public function setL1RpcTimeout(float $l1RpcTimeout): self
    {
        $this->initialized['l1RpcTimeout'] = true;
        $this->l1RpcTimeout = $l1RpcTimeout;

        return $this;
    }

    public function getLoopRetryDelay(): float
    {
        return $this->loopRetryDelay;
    }

    public function setLoopRetryDelay(float $loopRetryDelay): self
    {
        $this->initialized['loopRetryDelay'] = true;
        $this->loopRetryDelay = $loopRetryDelay;

        return $this;
    }

    /**
     * Deprecated.
     */
    public function getIndexBufferSize(): int
    {
        return $this->indexBufferSize;
    }

    /**
     * Deprecated.
     */
    public function setIndexBufferSize(int $indexBufferSize): self
    {
        $this->initialized['indexBufferSize'] = true;
        $this->indexBufferSize = $indexBufferSize;

        return $this;
    }

    public function getIrminCacheSize(): int
    {
        return $this->irminCacheSize;
    }

    public function setIrminCacheSize(int $irminCacheSize): self
    {
        $this->initialized['irminCacheSize'] = true;
        $this->irminCacheSize = $irminCacheSize;

        return $this;
    }

    public function getLogKernelDebug(): bool
    {
        return $this->logKernelDebug;
    }

    public function setLogKernelDebug(bool $logKernelDebug): self
    {
        $this->initialized['logKernelDebug'] = true;
        $this->logKernelDebug = $logKernelDebug;

        return $this;
    }

    public function getNoDegraded(): bool
    {
        return $this->noDegraded;
    }

    public function setNoDegraded(bool $noDegraded): self
    {
        $this->initialized['noDegraded'] = true;
        $this->noDegraded = $noDegraded;

        return $this;
    }

    public function getGcParameters(): ConfigGetResponse200GcParameters
    {
        return $this->gcParameters;
    }

    public function setGcParameters(ConfigGetResponse200GcParameters $gcParameters): self
    {
        $this->initialized['gcParameters'] = true;
        $this->gcParameters = $gcParameters;

        return $this;
    }

    public function getHistoryMode(): string
    {
        return $this->historyMode;
    }

    public function setHistoryMode(string $historyMode): self
    {
        $this->initialized['historyMode'] = true;
        $this->historyMode = $historyMode;

        return $this;
    }

    public function getCors(): ConfigGetResponse200Cors
    {
        return $this->cors;
    }

    public function setCors(ConfigGetResponse200Cors $cors): self
    {
        $this->initialized['cors'] = true;
        $this->cors = $cors;

        return $this;
    }

    public function getBailOnDisagree(): bool
    {
        return $this->bailOnDisagree;
    }

    public function setBailOnDisagree(bool $bailOnDisagree): self
    {
        $this->initialized['bailOnDisagree'] = true;
        $this->bailOnDisagree = $bailOnDisagree;

        return $this;
    }
}
