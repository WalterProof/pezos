<?php

declare(strict_types=1);

/*
 * This file has been auto generated by Jane,
 *
 * Do no edit it directly.
 */

namespace Pezos\Generated\Rollup;

class Client extends Runtime\Client\Client
{
    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getAdminCancelGc(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetAdminCancelGc(), $fetch);
    }

    /**
     * Clear operation queues of injectors.
     *
     * @param array $queryParameters {
     *
     * @var string $tag A kind of operation for the injector.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function deleteAdminInjectorQueue(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteAdminInjectorQueue($queryParameters), $fetch);
    }

    /**
     * Get operation queues of injectors.
     *
     * @param array $queryParameters {
     *
     * @var string $tag A kind of operation for the injector.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\AdminInjectorQueuesGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getAdminInjectorQueues(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetAdminInjectorQueues($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\AdminInjectorQueuesTotalGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getAdminInjectorQueuesTotal(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetAdminInjectorQueuesTotal(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ConfigGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getConfig(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetConfig(), $fetch);
    }

    /**
     * RPCs documentation and input/output schema.
     *
     * @param array $queryParameters {
     *
     * @var string $recurse
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getDescribe(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetDescribe($queryParameters), $fetch);
    }

    /**
     * Layer-2 block of the layer-2 chain with respect to a Layer 1 block identifier.
     *
     * @param string $blockId         an L1 block identifier
     * @param array  $queryParameters {
     *
     * @var string $outbox
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\GlobalBlockBlockIdGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockId(string $blockId, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockId($blockId, $queryParameters), $fetch);
    }

    /**
     * Data availability processed slots and their statuses.
     *
     * @param string $blockId an L1 block identifier
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\GlobalBlockBlockIdDalProcessedSlotsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdDalProcessedSlots(string $blockId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdDalProcessedSlots($blockId), $fetch);
    }

    /**
     * Availability slots for a given block.
     *
     * @param string $blockId an L1 block identifier
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\GlobalBlockBlockIdDalSlotHeadersGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdDalSlotHeaders(string $blockId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdDalSlotHeaders($blockId), $fetch);
    }

    /**
     * Retrieve number of bytes in raw representation of value by key from PVM durable storage. PVM state is taken with respect to the specified block level.
     *
     * @param string $blockId         an L1 block identifier
     * @param array  $queryParameters {
     *
     * @var string $key
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdDurableWasm200Length(string $blockId, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdDurableWasm200Length($blockId, $queryParameters), $fetch);
    }

    /**
     * Retrieve subkeys of the specified key from PVM durable storage. PVM state is taken with respect to the specified block level.
     *
     * @param string $blockId         an L1 block identifier
     * @param array  $queryParameters {
     *
     * @var string $key
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdDurableWasm200Subkeys(string $blockId, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdDurableWasm200Subkeys($blockId, $queryParameters), $fetch);
    }

    /**
     * Retrieve value by key from PVM durable storage. PVM state is taken with respect to the specified block level. Value returned in hex format.
     *
     * @param string $blockId         an L1 block identifier
     * @param array  $queryParameters {
     *
     * @var string $key
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdDurableWasm200Value(string $blockId, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdDurableWasm200Value($blockId, $queryParameters), $fetch);
    }

    /**
     * Tezos block hash of block known to the smart rollup node.
     *
     * @param string $blockId an L1 block identifier
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdHash(string $blockId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdHash($blockId), $fetch);
    }

    /**
     * Generate serialized output proof for some outbox message at level and index.
     *
     * @param string $blockId         an L1 block identifier
     * @param array  $queryParameters {
     *
     * @var string $index
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\GlobalBlockBlockIdHelpersProofsOutboxLevelMessagesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdHelpersProofsOutboxByLevelMessage(string $blockId, string $level, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdHelpersProofsOutboxByLevelMessage($blockId, $level, $queryParameters), $fetch);
    }

    /**
     * Rollup inbox for block.
     *
     * @param string $blockId an L1 block identifier
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\GlobalBlockBlockIdInboxGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdInbox(string $blockId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdInbox($blockId), $fetch);
    }

    /**
     * Level of Tezos block known to the smart rollup node.
     *
     * @param string $blockId an L1 block identifier
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdLevel(string $blockId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdLevel($blockId), $fetch);
    }

    /**
     * Number of messages for specified block.
     *
     * @param string $blockId an L1 block identifier
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdNumMessage(string $blockId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdNumMessage($blockId), $fetch);
    }

    /**
     * Outbox at block for a given outbox level.
     *
     * @param string $blockId         an L1 block identifier
     * @param array  $queryParameters {
     *
     * @var string $outbox_level
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\GlobalBlockBlockIdOutboxGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdOutbox(string $blockId, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdOutbox($blockId, $queryParameters), $fetch);
    }

    /**
     * Outbox at block for a given outbox level.
     *
     * @param string $blockId an L1 block identifier
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\GlobalBlockBlockIdOutboxLevelMessagesGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdOutboxByLevelMessages(string $blockId, string $level, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdOutboxByLevelMessages($blockId, $level), $fetch);
    }

    /**
     * Simulate messages evaluation by the PVM.
     *
     * @param string $blockId an L1 block identifier
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\GlobalBlockBlockIdSimulatePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postGlobalBlockByBlockIdSimulate(string $blockId, ?Model\GlobalBlockBlockIdSimulatePostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostGlobalBlockByBlockIdSimulate($blockId, $requestBody), $fetch);
    }

    /**
     * Retrieve value from key is PVM state of specified block.
     *
     * @param string $blockId         an L1 block identifier
     * @param array  $queryParameters {
     *
     * @var string $key
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdState(string $blockId, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdState($blockId, $queryParameters), $fetch);
    }

    /**
     * Retrieve the current level of a PVM.
     *
     * @param string $blockId an L1 block identifier
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdStateCurrentLevel(string $blockId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdStateCurrentLevel($blockId), $fetch);
    }

    /**
     * State hash for this block.
     *
     * @param string $blockId an L1 block identifier
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdStateHash(string $blockId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdStateHash($blockId), $fetch);
    }

    /**
     * PVM status at block.
     *
     * @param string $blockId an L1 block identifier
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdStatus(string $blockId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdStatus($blockId), $fetch);
    }

    /**
     * Number of ticks for specified level.
     *
     * @param string $blockId an L1 block identifier
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdTick(string $blockId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdTick($blockId), $fetch);
    }

    /**
     * Total number of ticks at specified block.
     *
     * @param string $blockId an L1 block identifier
     * @param string $fetch   Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalBlockByBlockIdTotalTick(string $blockId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalBlockByBlockIdTotalTick($blockId), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalLastStoredCommitment(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalLastStoredCommitment(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\GlobalMonitorBlocksGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalMonitorBlock(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalMonitorBlock(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalSmartRollupAddress(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalSmartRollupAddress(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalTezosHead(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalTezosHead(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getGlobalTezosLevel(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGlobalTezosLevel(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HealthGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getHealth(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetHealth(), $fetch);
    }

    /**
     * Inject messages in the batcher's queue.
     *
     * @param array[]|null $requestBody
     * @param array        $queryParameters {
     *
     * @var string $drop_duplicate
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postLocalBatcherInjection(?array $requestBody = null, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostLocalBatcherInjection($requestBody, $queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\LocalBatcherQueueGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getLocalBatcherQueue(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLocalBatcherQueue(), $fetch);
    }

    /**
     * Retrieve an L2 message and its status.
     *
     * @param string $l2MessageId a L2 message id
     * @param string $fetch       Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getLocalBatcherQueueByL2MessageId(string $l2MessageId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLocalBatcherQueueByL2MessageId($l2MessageId), $fetch);
    }

    /**
     * Commitment computed and published by the node.
     *
     * @param string $commitmentHash a commitment hash
     * @param string $fetch          Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getLocalCommitmentByCommitmentHash(string $commitmentHash, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLocalCommitmentByCommitmentHash($commitmentHash), $fetch);
    }

    /**
     * Inject the given messages in the DAL queue, even in case of duplicates.
     *
     * @param array[]|null $requestBody
     * @param string       $fetch       Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postLocalDalBatcherInjection(?array $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostLocalDalBatcherInjection($requestBody), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\LocalDalInjectedOperationsStatusesGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getLocalDalInjectedOperationsStatuses(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLocalDalInjectedOperationsStatuses(), $fetch);
    }

    /**
     * Forget information about the injection whose id is given.
     *
     * @param string     $injectorOperationHash injector_operation_hash (Base58Check-encoded)
     * @param mixed|null $requestBody
     * @param string     $fetch                 Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postLocalDalInjectionByInjectorOperationHashForget(string $injectorOperationHash, $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostLocalDalInjectionByInjectorOperationHashForget($injectorOperationHash, $requestBody), $fetch);
    }

    /**
     * Provide the (new) list of slot indices to use to the rollup node's DAL injector.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postLocalDalSlotIndex(?Model\LocalDalSlotIndicesPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostLocalDalSlotIndex($requestBody), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\LocalGcInfoGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getLocalGcInfo(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLocalGcInfo(), $fetch);
    }

    /**
     * Retrieve the status of the injected operation using its injector ID.
     *
     * @param string $injectorOperationHash injector_operation_hash (Base58Check-encoded)
     * @param string $fetch                 Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getLocalInjectorOperationByInjectorOperationHashStatus(string $injectorOperationHash, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLocalInjectorOperationByInjectorOperationHashStatus($injectorOperationHash), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getLocalLastPublishedCommitment(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLocalLastPublishedCommitment(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\LocalOutboxPendingExecutableGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getLocalOutboxPendingExecutable(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLocalOutboxPendingExecutable(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\LocalOutboxPendingUnexecutableGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getLocalOutboxPendingUnexecutable(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLocalOutboxPendingUnexecutable(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getLocalSynchronized(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLocalSynchronized(), $fetch);
    }

    /**
     * OpenAPI specification of RPCs for rollup node.
     *
     * @param array $queryParameters {
     *
     * @var string $protocol Protocol_hash (Base58Check-encoded)
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getOpenapi(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOpenapi($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getPing(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetPing(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getStatsMemory(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetStatsMemory(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\StatsOcamlGcGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getStatsOcamlGc(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetStatsOcamlGc(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VersionGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getVersion(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVersion(), $fetch);
    }

    public static function create($httpClient = null, array $additionalPlugins = [], array $additionalNormalizers = [])
    {
        if (null === $httpClient) {
            $httpClient = \Http\Discovery\Psr18ClientDiscovery::find();
            $plugins = [];
            if (count($additionalPlugins) > 0) {
                $plugins = array_merge($plugins, $additionalPlugins);
            }
            $httpClient = new \Http\Client\Common\PluginClient($httpClient, $plugins);
        }
        $requestFactory = \Http\Discovery\Psr17FactoryDiscovery::findRequestFactory();
        $streamFactory = \Http\Discovery\Psr17FactoryDiscovery::findStreamFactory();
        $normalizers = [new \Symfony\Component\Serializer\Normalizer\ArrayDenormalizer(), new Normalizer\JaneObjectNormalizer()];
        if (count($additionalNormalizers) > 0) {
            $normalizers = array_merge($normalizers, $additionalNormalizers);
        }
        $serializer = new \Symfony\Component\Serializer\Serializer($normalizers, [new \Symfony\Component\Serializer\Encoder\JsonEncoder(new \Symfony\Component\Serializer\Encoder\JsonEncode(), new \Symfony\Component\Serializer\Encoder\JsonDecode(['json_decode_associative' => true]))]);

        return new static($httpClient, $requestFactory, $serializer, $streamFactory);
    }
}
