<?php

declare(strict_types=1);

/*
 * This file has been auto generated by Jane,
 *
 * Do no edit it directly.
 */

namespace Pezos\Generated\Proto;

class Client extends Runtime\Client\Client
{
    /**
     * All the information about a block. The associated metadata may not be present depending on the history mode and block's distance from the head.
     *
     * @param array $queryParameters {
     *
     * @var string $version Supported RPC versions are version "1" (default)
     * @var string $force_metadata DEPRECATED: Forces to recompute the operations metadata if it was considered as too large
     * @var string $metadata defines the way metadata are queried Specifies whether or not if the operations metadata should be returned. To get the metadata, even if it is needed to recompute them, use "always". To avoid getting the metadata, use "never". By default, the metadata will be returned depending on the node's metadata size limit policy.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\GetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function get(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\Get($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextAdaptiveIssuanceLaunchCycle(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextAdaptiveIssuanceLaunchCycle(), $fetch);
    }

    /**
     * Get the (optionally paginated) list of values in a big map. Order of values is unspecified, but is guaranteed to be consistent.
     *
     * @param string $bigMapId        A big map identifier
     * @param array  $queryParameters {
     *
     * @var string $offset A non-negative integer (greater than or equal to 0). Skip the first [offset] values. Useful in combination with [length] for pagination.
     * @var string $length A non-negative integer (greater than or equal to 0). Only retrieve [length] values. Useful in combination with [offset] for pagination.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextBigMapsByBigMapId(string $bigMapId, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextBigMapsByBigMapId($bigMapId, $queryParameters), $fetch);
    }

    /**
     * Access the value associated with a key in a big map.
     *
     * @param string $bigMapId   A big map identifier
     * @param string $scriptExpr script_expr (Base58Check-encoded)
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextBigMapByBigMapIdByScriptExpr(string $bigMapId, string $scriptExpr, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextBigMapByBigMapIdByScriptExpr($bigMapId, $scriptExpr), $fetch);
    }

    /**
     * Access the value associated with a key in a big map, normalize the output using the requested unparsing mode.
     *
     * @param string $bigMapId   A big map identifier
     * @param string $scriptExpr script_expr (Base58Check-encoded)
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postContextBigMapsByBigMapIdByScriptExprNormalized(string $bigMapId, string $scriptExpr, ?Model\ContextBigMapsBigMapIdScriptExprNormalizedPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostContextBigMapsByBigMapIdByScriptExprNormalized($bigMapId, $scriptExpr, $requestBody), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextCacheContractsAll(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextCacheContractsAll(), $fetch);
    }

    /**
     * Return the number of cached contracts older than the provided contract.
     *
     * @param mixed|null $requestBody
     * @param string     $fetch       Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postContextCacheContractsRank($requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostContextCacheContractsRank($requestBody), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextCacheContractsSize(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextCacheContractsSize(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextCacheContractsSizeLimit(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextCacheContractsSizeLimit(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextConstantsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextConstant(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextConstant(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextConstantsError(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextConstantsError(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextConstantsParametricGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextConstantsParametric(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextConstantsParametric(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContracts(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContracts(), $fetch);
    }

    /**
     * Access the complete status of a contract.
     *
     * @param string $contractId      a contract identifier encoded in b58check
     * @param array  $queryParameters {
     *
     * @var string $normalize_types Whether types should be normalized (annotations removed, combs flattened) or kept as they appeared in the original script.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextContractsContractIdGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractByContractId(string $contractId, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractByContractId($contractId, $queryParameters), $fetch);
    }

    /**
     * Access the complete list of tickets owned by the given contract by scanning the contract's storage.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextContractsContractIdAllTicketBalancesGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdAllTicketBalances(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdAllTicketBalances($contractId), $fetch);
    }

    /**
     * The spendable balance of a contract (in mutez), also known as liquid balance. Corresponds to tez owned by the contract that are neither staked, nor in unstaked requests, nor in frozen bonds. Identical to the 'spendable' RPC.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdBalance(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdBalance($contractId), $fetch);
    }

    /**
     * The sum (in mutez) of the spendable balance and frozen bonds of a contract. Corresponds to the contract's full balance from which staked funds and unstake requests have been excluded. Identical to the 'spendable_and_frozen_bonds' RPC.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdBalanceAndFrozenBond(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdBalanceAndFrozenBond($contractId), $fetch);
    }

    /**
     * Access the value associated with a key in a big map of the contract (deprecated).
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postContextContractsByContractIdBigMapGet(string $contractId, ?Model\ContextContractsContractIdBigMapGetPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostContextContractsByContractIdBigMapGet($contractId, $requestBody), $fetch);
    }

    /**
     * Access the counter of a contract, if any.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdCounter(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdCounter($contractId), $fetch);
    }

    /**
     * Access the delegate of a contract, if any.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdDelegate(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdDelegate($contractId), $fetch);
    }

    /**
     * Return the list of entrypoints of the contract.
     *
     * @param string $contractId      a contract identifier encoded in b58check
     * @param array  $queryParameters {
     *
     * @var string $normalize_types Whether types should be normalized (annotations removed, combs flattened) or kept as they appeared in the original script.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextContractsContractIdEntrypointsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdEntrypoint(string $contractId, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdEntrypoint($contractId, $queryParameters), $fetch);
    }

    /**
     * Return the type of the given entrypoint of the contract.
     *
     * @param string $contractId      a contract identifier encoded in b58check
     * @param string $entrypoint      A Michelson entrypoint (string of length < 32)
     * @param array  $queryParameters {
     *
     * @var string $normalize_types Whether types should be normalized (annotations removed, combs flattened) or kept as they appeared in the original script.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdEntrypointByEntrypoint(string $contractId, string $entrypoint, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdEntrypointByEntrypoint($contractId, $entrypoint, $queryParameters), $fetch);
    }

    /**
     * Returns the estimated own pending slashed amount (in mutez) of a given contract.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdEstimatedOwnPendingSlashedAmount(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdEstimatedOwnPendingSlashedAmount($contractId), $fetch);
    }

    /**
     * Access the frozen bonds of a contract.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdFrozenBond(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdFrozenBond($contractId), $fetch);
    }

    /**
     * The full balance (in mutez) of the contract. Includes its spendable balance, staked tez, unstake requests, and frozen bonds. Even if the contract is a delegate, it does not include any staked or delegated tez owned by external delegators.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdFullBalance(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdFullBalance($contractId), $fetch);
    }

    /**
     * Access the manager of an implicit contract.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdManagerKey(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdManagerKey($contractId), $fetch);
    }

    /**
     * Access the code and data of the contract.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextContractsContractIdScriptGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdScript(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdScript($contractId), $fetch);
    }

    /**
     * Access the script of the contract and normalize it using the requested unparsing mode.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postContextContractsByContractIdScriptNormalized(string $contractId, ?Model\ContextContractsContractIdScriptNormalizedPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostContextContractsByContractIdScriptNormalized($contractId, $requestBody), $fetch);
    }

    /**
     * Returns the root and a diff of a state starting from an optional offset which is zero by default.
     *
     * @param string $contractId      a contract identifier encoded in b58check
     * @param array  $queryParameters {
     *
     * @var string $offset_commitment commitments and ciphertexts are returned from the specified offset up to the most recent
     * @var string $offset_nullifier Nullifiers are returned from the specified offset up to the most recent.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextContractsContractIdSingleSaplingGetDiffGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdSingleSaplingGetDiff(string $contractId, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdSingleSaplingGetDiff($contractId, $queryParameters), $fetch);
    }

    /**
     * The spendable balance of a contract (in mutez), also known as liquid balance. Corresponds to tez owned by the contract that are neither staked, nor in unstaked requests, nor in frozen bonds. Identical to the 'balance' RPC.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdSpendable(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdSpendable($contractId), $fetch);
    }

    /**
     * The sum (in mutez) of the spendable balance and frozen bonds of a contract. Corresponds to the contract's full balance from which staked funds and unstake requests have been excluded. Identical to the 'balance_and_frozen_bonds' RPC.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdSpendableAndFrozenBond(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdSpendableAndFrozenBond($contractId), $fetch);
    }

    /**
     * Access the staked balance of a contract (in mutez). Returns None if the contract is originated, or neither delegated nor a delegate.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdStakedBalance(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdStakedBalance($contractId), $fetch);
    }

    /**
     * Returns an abstract representation of the contract's total_delegated_stake.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdStakingNumerator(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdStakingNumerator($contractId), $fetch);
    }

    /**
     * Access the data of the contract.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdStorage(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdStorage($contractId), $fetch);
    }

    /**
     * Access the data of the contract and normalize it using the requested unparsing mode.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postContextContractsByContractIdStorageNormalized(string $contractId, ?Model\ContextContractsContractIdStorageNormalizedPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostContextContractsByContractIdStorageNormalized($contractId, $requestBody), $fetch);
    }

    /**
     * Access the paid storage space of the contract.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdStoragePaidSpace(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdStoragePaidSpace($contractId), $fetch);
    }

    /**
     * Access the used storage space of the contract.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdStorageUsedSpace(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdStorageUsedSpace($contractId), $fetch);
    }

    /**
     * Access the contract's balance of ticket with specified ticketer, content type, and content.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postContextContractsByContractIdTicketBalance(string $contractId, ?Model\ContextContractsContractIdTicketBalancePostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostContextContractsByContractIdTicketBalance($contractId, $requestBody), $fetch);
    }

    /**
     * Access the unstake requests of the contract. The requests that appear in the finalizable field can be finalized, which means that the contract can transfer these (no longer frozen) funds to their spendable balance with a [finalize_unstake] operation call. Returns None if there is no unstake request pending.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdUnstakeRequest(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdUnstakeRequest($contractId), $fetch);
    }

    /**
     * Access the balance of a contract that was requested for an unstake operation, and is no longer frozen, which means it will appear in the spendable balance of the contract after any stake/unstake/finalize_unstake operation. Returns None if the contract is originated.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdUnstakedFinalizableBalance(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdUnstakedFinalizableBalance($contractId), $fetch);
    }

    /**
     * Access the balance of a contract that was requested for an unstake operation, but is still frozen for the duration of the slashing period. Returns None if the contract is originated.
     *
     * @param string $contractId a contract identifier encoded in b58check
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextContractsByContractIdUnstakedFrozenBalance(string $contractId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextContractsByContractIdUnstakedFrozenBalance($contractId), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDalCommitmentsHistory(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDalCommitmentsHistory(), $fetch);
    }

    /**
     * Get the published slots headers for the given level.
     *
     * @param array $queryParameters {
     *
     * @var string $level A level integer
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextDalPublishedSlotHeadersGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDalPublishedSlotHeaders(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDalPublishedSlotHeaders($queryParameters), $fetch);
    }

    /**
     * Get the shards assignment for a given level (the default is the current level) and given delegates (the default is all delegates).
     *
     * @param array $queryParameters {
     *
     * @var string $level A level integer
     * @var string $delegates A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextDalShardsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDalShards(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDalShards($queryParameters), $fetch);
    }

    /**
     * Lists all registered delegates by default. The arguments `active`, `inactive`, `with_minimal_stake`, and `without_minimal_stake` allow to enumerate only the delegates that are active, inactive, have at least a minimal stake to participate in consensus and in governance, or do not have such a minimal stake, respectively. Note, setting these arguments to false has no effect.
     *
     * @param array $queryParameters {
     *
     * @var string $active
     * @var string $inactive
     * @var string $with_minimal_stake
     * @var string $without_minimal_stake
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegates(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegates($queryParameters), $fetch);
    }

    /**
     * Everything about a delegate. Gathers the outputs of all RPCs with the ../delegates/<pkh> prefix.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextDelegatesPkhGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegateByPkh(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegateByPkh($pkh), $fetch);
    }

    /**
     * Returns the currently active staking parameters for the given delegate.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextDelegatesPkhActiveStakingParametersGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhActiveStakingParameter(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhActiveStakingParameter($pkh), $fetch);
    }

    /**
     * The current baking power of a delegate, using the current staked and delegated balances of the baker and its delegators. In other words, the baking rights that the baker would get for a future cycle if the current cycle ended right at the current block.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhBakingPower(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhBakingPower($pkh), $fetch);
    }

    /**
     * The active consensus key for a given delegate and the pending consensus keys.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextDelegatesPkhConsensusKeyGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhConsensusKey(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhConsensusKey($pkh), $fetch);
    }

    /**
     * DEPRECATED; use baking_power instead.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhCurrentBakingPower(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhCurrentBakingPower($pkh), $fetch);
    }

    /**
     * DEPRECATED; use total_staked instead.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhCurrentFrozenDeposit(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhCurrentFrozenDeposit($pkh), $fetch);
    }

    /**
     * The voting power of a given delegate, as computed from its current stake.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhCurrentVotingPower(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhCurrentVotingPower($pkh), $fetch);
    }

    /**
     * Tells whether the delegate is currently tagged as deactivated or not.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhDeactivated(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhDeactivated($pkh), $fetch);
    }

    /**
     * DEPRECATED; to get this value, you can call RPCs external_staked and external_delegated, and add their outputs together.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhDelegatedBalance(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhDelegatedBalance($pkh), $fetch);
    }

    /**
     * DEPRECATED; use delegators instead.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhDelegatedContracts(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhDelegatedContracts($pkh), $fetch);
    }

    /**
     * The list of all contracts that are currently delegating to the delegate. Includes both user accounts and smart contracts. Includes the delegate itself.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhDelegators(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhDelegators($pkh), $fetch);
    }

    /**
     * Returns the pending denunciations for the given delegate.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextDelegatesPkhDenunciationsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhDenunciations(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhDenunciations($pkh), $fetch);
    }

    /**
     * Returns the estimated shared pending slashed amount (in mutez) of a given delegate.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhEstimatedSharedPendingSlashedAmount(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhEstimatedSharedPendingSlashedAmount($pkh), $fetch);
    }

    /**
     * The sum (in mutez) of non-staked tokens that currently count as delegated to the baker, excluding those owned by the baker iself. Does not take limits such as overstaking or overdelegation into account. This includes the spendable balances and frozen bonds of all the baker's external delegators. It also includes unstake requests of contracts other than the baker, on the condition that the contract was delegating to the baker at the time of the unstake operation. So this includes most but not all unstake requests from current delegators, and might include some unstake requests from old delegators. Limits such as overstaking and overdelegation have not been applied yet.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhExternalDelegated(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhExternalDelegated($pkh), $fetch);
    }

    /**
     * The sum (in mutez) of all tokens currently staked by the baker's external delegators. This excludes the baker's own staked tokens.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhExternalStaked(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhExternalStaked($pkh), $fetch);
    }

    /**
     * DEPRECATED; call RPC total_staked on the last block of (current_cycle - 3) instead. Returns the total amount (in mutez) that was staked for the baker by all stakers (including the baker itself) at the time the staking rights for the current cycle were computed.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhFrozenDeposit(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhFrozenDeposit($pkh), $fetch);
    }

    /**
     * DEPRECATED; the frozen deposits limit has no effects since the activation of Adaptive Issuance and Staking during the Paris protocol.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhFrozenDepositsLimit(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhFrozenDepositsLimit($pkh), $fetch);
    }

    /**
     * DEPRECATED; use own_full_balance instead.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhFullBalance(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhFullBalance($pkh), $fetch);
    }

    /**
     * Returns the cycle by the end of which the delegate might be deactivated if she fails to execute any delegate action. A deactivated delegate might be reactivated (without loosing any stake) by simply re-registering as a delegate. For deactivated delegates, this value contains the cycle at which they were deactivated.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhGracePeriod(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhGracePeriod($pkh), $fetch);
    }

    /**
     * Returns true if the delegate is forbidden to participate in consensus.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhIsForbidden(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhIsForbidden($pkh), $fetch);
    }

    /**
     * Returns the minimum of delegated tez (in mutez) during the current cycle and the block level at the end of which the minimum was reached. This only takes into account the value of `total_delegated` at the end of each block, not in the middle of applying operations. This is the delegated amount that would be used to compute the delegate's future baking rights if the cycle ended at the current block. If the minimum was reached multiple times, the returned level is the earliest level of the current cycle that reached this minimum. For instance, if `total_delegated` hasn't changed at all since the beginning of the current cycle, returns the first level of the current cycle. (If the contract is not registered as a delegate, returns 0 mutez and omits the level.).
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextDelegatesPkhMinDelegatedInCurrentCycleGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhMinDelegatedInCurrentCycle(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhMinDelegatedInCurrentCycle($pkh), $fetch);
    }

    /**
     * The amount (in mutez) currently owned by the baker itself and counting as delegated for the purpose of baking rights. This corresponds to all non-staked tokens owned by the baker: spendable balance, frozen bonds, and unstake requests. (Note: There is one exception: if the baker still has unstake requests created at a time when it was delegating to a different delegate, then these unstake requests still count as delegated to the former delegate. Any such unstake requests are excluded from the amount returned by the present RPC, despite being non-staked tokens owned by the baker.).
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhOwnDelegated(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhOwnDelegated($pkh), $fetch);
    }

    /**
     * The full balance (in mutez) of tokens owned by the delegate itself. Includes its spendable balance, staked tez, unstake requests, and frozen bonds. Does not include any tokens owned by external delegators. This RPC fails when the pkh is not a delegate. When it is a delegate, this RPC outputs the same amount as ../<block_id>/context/contracts/<delegate_contract_id>/full_balance.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhOwnFullBalance(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhOwnFullBalance($pkh), $fetch);
    }

    /**
     * The amount (in mutez) currently owned and staked by the baker itself. Returns the same value as ../<block_id>/context/contracts/<delegate_contract_id>/staked_balance (except for the fact that the present RPC fails if the public_key_hash in the path is not a delegate).
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhOwnStaked(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhOwnStaked($pkh), $fetch);
    }

    /**
     * Returns cycle and level participation information. In particular this indicates, in the field 'expected_cycle_activity', the number of slots the delegate is expected to have in the cycle based on its active stake. The field 'minimal_cycle_activity' indicates the minimal attesting slots in the cycle required to get attesting rewards. It is computed based on 'expected_cycle_activity. The fields 'missed_slots' and 'missed_levels' indicate the number of missed attesting slots and missed levels (for attesting) in the cycle so far. 'missed_slots' indicates the number of missed attesting slots in the cycle so far. The field 'remaining_allowed_missed_slots' indicates the remaining amount of attesting slots that can be missed in the cycle before forfeiting the rewards. Finally, 'expected_attesting_rewards' indicates the attesting rewards that will be distributed at the end of the cycle if activity at that point will be greater than the minimal required; if the activity is already known to be below the required minimum, then the rewards are zero.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextDelegatesPkhParticipationGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhParticipation(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhParticipation($pkh), $fetch);
    }

    /**
     * Returns the pending values for the given delegate's staking parameters.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextDelegatesPkhPendingStakingParametersGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhPendingStakingParameters(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhPendingStakingParameters($pkh), $fetch);
    }

    /**
     * Returns the list of accounts that stake to a given delegate together with their share of the frozen deposits.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextDelegatesPkhStakersGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhStakers(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhStakers($pkh), $fetch);
    }

    /**
     * DEPRECATED; to get this value, you can call RPCs total_staked and total_delegated, and add their outputs together.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhStakingBalance(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhStakingBalance($pkh), $fetch);
    }

    /**
     * Returns an abstract representation of the total delegated stake.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhStakingDenominator(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhStakingDenominator($pkh), $fetch);
    }

    /**
     * All tokens (in mutez) that currently count as delegated for the purpose of computing the baker's rights; they weigh half as much as staked tez in the rights. Limits such as overstaking and overdelegation have not been applied yet. This corresponds to all non-staked tez owned by the baker's delegators (including the baker itself): spendable balances, frozen bonds, and unstaked requests, except for any unstake requests that have been created before the delegator changed its delegate to the current baker (because they still count as delegated for the old delegate instead).
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhTotalDelegated(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhTotalDelegated($pkh), $fetch);
    }

    /**
     * DEPRECATED; use external_staked instead.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhTotalDelegatedStake(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhTotalDelegatedStake($pkh), $fetch);
    }

    /**
     * The total amount (in mutez) currently staked for the baker, both by the baker itself and by external stakers. This is the staked amount before applying the baker's 'limit_of_staking_over_baking'; in other words, it includes overstaked tez if there are any.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhTotalStaked(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhTotalStaked($pkh), $fetch);
    }

    /**
     * For each cycle, returns the total amount (in mutez) contained in all unstake requests created during this cycle by all delegators, including the baker itself. Note that these tokens count as delegated to the baker for the purpose of computing baking rights, and are included in the amount returned by the total_delegated RPC.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextDelegatesPkhTotalUnstakedPerCycleGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhTotalUnstakedPerCycle(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhTotalUnstakedPerCycle($pkh), $fetch);
    }

    /**
     * DEPRECATED; use total_unstaked_per_cycle instead.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextDelegatesPkhUnstakedFrozenDepositsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhUnstakedFrozenDeposits(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhUnstakedFrozenDeposits($pkh), $fetch);
    }

    /**
     * Returns the delegate info (e.g. voting power) found in the listings of the current voting period.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextDelegatesPkhVotingInfoGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhVotingInfo(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhVotingInfo($pkh), $fetch);
    }

    /**
     * The voting power in the vote listings for a given delegate.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDelegatesByPkhVotingPower(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDelegatesByPkhVotingPower($pkh), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextDenunciationsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextDenunciations(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextDenunciations(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextIssuanceCurrentYearlyRate(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextIssuanceCurrentYearlyRate(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextIssuanceCurrentYearlyRateDetailsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextIssuanceCurrentYearlyRateDetail(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextIssuanceCurrentYearlyRateDetail(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextIssuanceCurrentYearlyRateExactGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextIssuanceCurrentYearlyRateExact(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextIssuanceCurrentYearlyRateExact(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextIssuanceExpectedIssuanceGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextIssuanceExpectedIssuance(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextIssuanceExpectedIssuance(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextIssuanceIssuancePerMinute(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextIssuanceIssuancePerMinute(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextLiquidityBakingCpmmAddress(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextLiquidityBakingCpmmAddress(), $fetch);
    }

    /**
     * Returns the merkle tree of a piece of context.
     *
     * @param array $queryParameters {
     *
     * @var string $holey Send only hashes, omit data of key
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextMerkleTree(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextMerkleTree($queryParameters), $fetch);
    }

    /**
     * Returns the Irmin merkle tree of a piece of context.
     *
     * @param array $queryParameters {
     *
     * @var string $holey Send only hashes, omit data of key
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextMerkleTreeV2(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextMerkleTreeV2($queryParameters), $fetch);
    }

    /**
     * Info about the nonce of a previous block.
     *
     * @param string $blockLevel A level integer
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextNonceByBlockLevel(string $blockLevel, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextNonceByBlockLevel($blockLevel), $fetch);
    }

    /**
     * Returns the raw context.
     *
     * @param array $queryParameters {
     *
     * @var string $depth
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextRawByte(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextRawByte($queryParameters), $fetch);
    }

    /**
     * Returns the root and a diff of a state starting from an optional offset which is zero by default.
     *
     * @param string $saplingStateId  A sapling state identifier
     * @param array  $queryParameters {
     *
     * @var string $offset_commitment commitments and ciphertexts are returned from the specified offset up to the most recent
     * @var string $offset_nullifier Nullifiers are returned from the specified offset up to the most recent.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextSaplingSaplingStateIdGetDiffGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSaplingBySaplingStateIdGetDiff(string $saplingStateId, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSaplingBySaplingStateIdGetDiff($saplingStateId, $queryParameters), $fetch);
    }

    /**
     * Seed of the cycle to which the block belongs.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postContextSeed(?Model\ContextSeedPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostContextSeed($requestBody), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSeedComputation(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSeedComputation(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsAll(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsAll(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextSmartRollupsAllInboxGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsAllInbox(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsAllInbox(), $fetch);
    }

    /**
     * Commitment for a smart rollup from its hash.
     *
     * @param string $smartRollupAddress        smart_rollup_address (Base58Check-encoded)
     * @param string $smartRollupCommitmentHash smart_rollup_commitment_hash (Base58Check-encoded)
     * @param string $fetch                     Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextSmartRollupsSmartRollupSmartRollupAddressCommitmentSmartRollupCommitmentHashGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressCommitmentBySmartRollupCommitmentHash(string $smartRollupAddress, string $smartRollupCommitmentHash, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressCommitmentBySmartRollupCommitmentHash($smartRollupAddress, $smartRollupCommitmentHash), $fetch);
    }

    /**
     * Returns true if and only if the provided commitment can be cemented.
     *
     * @param string $smartRollupAddress        smart_rollup_address (Base58Check-encoded)
     * @param string $smartRollupCommitmentHash smart_rollup_commitment_hash (Base58Check-encoded)
     * @param string $fetch                     Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressCommitmentBySmartRollupCommitmentHashCanBeCemented(string $smartRollupAddress, string $smartRollupCommitmentHash, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressCommitmentBySmartRollupCommitmentHashCanBeCemented($smartRollupAddress, $smartRollupCommitmentHash), $fetch);
    }

    /**
     * List of stakers indexes staking on a given commitment.
     *
     * @param string $smartRollupAddress        smart_rollup_address (Base58Check-encoded)
     * @param string $smartRollupCommitmentHash smart_rollup_commitment_hash (Base58Check-encoded)
     * @param string $fetch                     Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressCommitmentBySmartRollupCommitmentHashStakersIndexes(string $smartRollupAddress, string $smartRollupCommitmentHash, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressCommitmentBySmartRollupCommitmentHashStakersIndexes($smartRollupAddress, $smartRollupCommitmentHash), $fetch);
    }

    /**
     * Return the known consumed outputs of a smart rollup.
     *
     * @param string $smartRollupAddress smart_rollup_address (Base58Check-encoded)
     * @param string $blockLevel         A level integer
     * @param string $fetch              Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressConsumedOutputsByBlockLevel(string $smartRollupAddress, string $blockLevel, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressConsumedOutputsByBlockLevel($smartRollupAddress, $blockLevel), $fetch);
    }

    /**
     * Genesis information (level and commitment hash) for a smart rollup.
     *
     * @param string $smartRollupAddress smart_rollup_address (Base58Check-encoded)
     * @param string $fetch              Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextSmartRollupsSmartRollupSmartRollupAddressGenesisInfoGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressGenesisInfo(string $smartRollupAddress, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressGenesisInfo($smartRollupAddress), $fetch);
    }

    /**
     * List of commitments associated to a rollup for a given inbox level.
     *
     * @param string $smartRollupAddress smart_rollup_address (Base58Check-encoded)
     * @param string $blockLevel         A level integer
     * @param string $fetch              Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressInboxLevelByBlockLevelCommitment(string $smartRollupAddress, string $blockLevel, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressInboxLevelByBlockLevelCommitment($smartRollupAddress, $blockLevel), $fetch);
    }

    /**
     * Kind of smart rollup.
     *
     * @param string $smartRollupAddress smart_rollup_address (Base58Check-encoded)
     * @param string $fetch              Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressKind(string $smartRollupAddress, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressKind($smartRollupAddress), $fetch);
    }

    /**
     * Level and hash of the last cemented commitment for a smart rollup.
     *
     * @param string $smartRollupAddress smart_rollup_address (Base58Check-encoded)
     * @param string $fetch              Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextSmartRollupsSmartRollupSmartRollupAddressLastCementedCommitmentHashWithLevelGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressLastCementedCommitmentHashWithLevel(string $smartRollupAddress, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressLastCementedCommitmentHashWithLevel($smartRollupAddress), $fetch);
    }

    /**
     * Last whitelist update for private smart rollups. If the output is None then the rollup is public.
     *
     * @param string $smartRollupAddress smart_rollup_address (Base58Check-encoded)
     * @param string $fetch              Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressLastWhitelistUpdate(string $smartRollupAddress, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressLastWhitelistUpdate($smartRollupAddress), $fetch);
    }

    /**
     * List of stakers in conflict with the given staker.
     *
     * @param string $smartRollupAddress smart_rollup_address (Base58Check-encoded)
     * @param string $pkh                A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch              Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextSmartRollupsSmartRollupSmartRollupAddressStakerPkhConflictsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressStakerByPkhConflicts(string $smartRollupAddress, string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressStakerByPkhConflicts($smartRollupAddress, $pkh), $fetch);
    }

    /**
     * Ongoing refutation games for a given staker.
     *
     * @param string $smartRollupAddress smart_rollup_address (Base58Check-encoded)
     * @param string $pkh                A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch              Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextSmartRollupsSmartRollupSmartRollupAddressStakerPkhGamesGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressStakerByPkhGames(string $smartRollupAddress, string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressStakerByPkhGames($smartRollupAddress, $pkh), $fetch);
    }

    /**
     * Staker index associated to a public key hash for a given rollup.
     *
     * @param string $smartRollupAddress smart_rollup_address (Base58Check-encoded)
     * @param string $pkh                A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch              Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressStakerByPkhIndex(string $smartRollupAddress, string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressStakerByPkhIndex($smartRollupAddress, $pkh), $fetch);
    }

    /**
     * The newest commitment on which the operator has staked on for a smart rollup. Note that is can return a commitment that is before the last cemented one.
     *
     * @param string $smartRollupAddress smart_rollup_address (Base58Check-encoded)
     * @param string $pkh                A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch              Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressStakerByPkhStakedOnCommitment(string $smartRollupAddress, string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressStakerByPkhStakedOnCommitment($smartRollupAddress, $pkh), $fetch);
    }

    /**
     * Returns the timeout of players.
     *
     * @param string $smartRollupAddress smart_rollup_address (Base58Check-encoded)
     * @param string $staker1Pkh         A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $staker2Pkh         A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch              Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressStaker1ByStaker1PkhStaker2ByStaker2PkhTimeout(string $smartRollupAddress, string $staker1Pkh, string $staker2Pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressStaker1ByStaker1PkhStaker2ByStaker2PkhTimeout($smartRollupAddress, $staker1Pkh, $staker2Pkh), $fetch);
    }

    /**
     * Returns whether the timeout creates a result for the game.
     *
     * @param string $smartRollupAddress smart_rollup_address (Base58Check-encoded)
     * @param string $staker1Pkh         A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $staker2Pkh         A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch              Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressStaker1ByStaker1PkhStaker2ByStaker2PkhTimeoutReached(string $smartRollupAddress, string $staker1Pkh, string $staker2Pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressStaker1ByStaker1PkhStaker2ByStaker2PkhTimeoutReached($smartRollupAddress, $staker1Pkh, $staker2Pkh), $fetch);
    }

    /**
     * List of active stakers' public key hashes of a rollup.
     *
     * @param string $smartRollupAddress smart_rollup_address (Base58Check-encoded)
     * @param string $fetch              Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressStakers(string $smartRollupAddress, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressStakers($smartRollupAddress), $fetch);
    }

    /**
     * Access the smart rollup's balance of ticket with specified ticketer, content type, and content.
     *
     * @param string $smartRollupAddress smart_rollup_address (Base58Check-encoded)
     * @param string $fetch              Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postContextSmartRollupsSmartRollupBySmartRollupAddressTicketBalance(string $smartRollupAddress, ?Model\ContextSmartRollupsSmartRollupSmartRollupAddressTicketBalancePostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostContextSmartRollupsSmartRollupBySmartRollupAddressTicketBalance($smartRollupAddress, $requestBody), $fetch);
    }

    /**
     * Whitelist for private smart rollups. If the output is None then the rollup is public.
     *
     * @param string $smartRollupAddress smart_rollup_address (Base58Check-encoded)
     * @param string $fetch              Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextSmartRollupsSmartRollupBySmartRollupAddressWhitelist(string $smartRollupAddress, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextSmartRollupsSmartRollupBySmartRollupAddressWhitelist($smartRollupAddress), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ContextTotalCurrentlyStakedGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getContextTotalCurrentlyStaked(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextTotalCurrentlyStaked(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextTotalFrozenStake(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextTotalFrozenStake(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getContextTotalSupply(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetContextTotalSupply(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getHash(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetHash(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HeaderGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getHeader(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetHeader(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HeaderProtocolDataGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getHeaderProtocolDatum(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetHeaderProtocolDatum(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getHeaderProtocolDataRaw(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetHeaderProtocolDataRaw(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getHeaderRaw(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetHeaderRaw(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HeaderShellGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getHeaderShell(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetHeaderShell(), $fetch);
    }

    /**
     * Retrieves the delegates allowed to attest a block.
     * By default, it gives the attestation power for delegates that have at least one attestation slot for the next block.
     * Parameters `level` and `cycle` can be used to specify the (valid) level(s) in the past or future at which the attestation rights have to be returned. Parameter `delegate` can be used to restrict the results to the given delegates.
     * Parameter `consensus_key` can be used to restrict the results to the given consensus_keys.
     * Returns the smallest attestation slots and the attestation power. Also returns the minimal timestamp that corresponds to attestation at the given level. The timestamps are omitted for levels in the past, and are only estimates for levels higher that the next block's, based on the hypothesis that all predecessor blocks were baked at the first round.
     *
     * @param array $queryParameters {
     *
     * @var string $level A level integer
     * @var string $cycle A cycle integer
     * @var string $delegate A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @var string $consensus_key A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersAttestationRightsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getHelpersAttestationRights(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetHelpersAttestationRights($queryParameters), $fetch);
    }

    /**
     * Retrieves the list of delegates allowed to bake a block.
     * By default, it gives the best baking opportunities (in terms of rounds) for bakers that have at least one opportunity below the 64th round for the next block.
     * Parameters `level` and `cycle` can be used to specify the (valid) level(s) in the past or future at which the baking rights have to be returned.
     * Parameter `delegate` can be used to restrict the results to the given delegates. Parameter `consensus_key` can be used to restrict the results to the given consensus_keys. If parameter `all` is set, all the baking opportunities for each baker at each level are returned, instead of just the first one.
     * Returns the list of baking opportunities up to round 64. Also returns the minimal timestamps that correspond to these opportunities. The timestamps are omitted for levels in the past, and are only estimates for levels higher that the next block's, based on the hypothesis that all predecessor blocks were baked at the first round.
     *
     * @param array $queryParameters {
     *
     * @var string $level A level integer
     * @var string $cycle A cycle integer
     * @var string $delegate A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @var string $consensus_key A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @var string $max_round
     * @var string $all
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersBakingRightsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getHelpersBakingRights(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetHelpersBakingRights($queryParameters), $fetch);
    }

    /**
     * Try to complete a prefix of a Base58Check-encoded data. This RPC is actually able to complete hashes of block, operations, public_keys and contracts.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getHelpersCompleteByPrefix(string $prefix, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetHelpersCompleteByPrefix($prefix), $fetch);
    }

    /**
     * Returns the level of the interrogated block, or the one of a block located `offset` blocks after it in the chain. For instance, the next block if `offset` is 1. The offset cannot be negative.
     *
     * @param array $queryParameters {
     *
     * @var string $offset
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersCurrentLevelGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getHelpersCurrentLevel(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetHelpersCurrentLevel($queryParameters), $fetch);
    }

    /**
     * Forge an operation.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersForgeOperation(?Model\HelpersForgeOperationsPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersForgeOperation($requestBody), $fetch);
    }

    /**
     * Forge the protocol-specific part of a block header.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersForgeProtocolDataPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersForgeProtocolDatum(?Model\HelpersForgeProtocolDataPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersForgeProtocolDatum($requestBody), $fetch);
    }

    /**
     * Forge a block header.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersForgeBlockHeaderPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersForgeBlockHeader(?Model\HelpersForgeBlockHeaderPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersForgeBlockHeader($requestBody), $fetch);
    }

    /**
     * Levels of a cycle.
     *
     * @param array $queryParameters {
     *
     * @var string $offset
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersLevelsInCurrentCycleGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getHelpersLevelsInCurrentCycle(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetHelpersLevelsInCurrentCycle($queryParameters), $fetch);
    }

    /**
     * Parse a block.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersParseBlockPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersParseBlock(?Model\HelpersParseBlockPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersParseBlock($requestBody), $fetch);
    }

    /**
     * Parse operations.
     *
     * @param array $queryParameters {
     *
     * @var string $version Supported RPC version is version '1'
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersParseOperationsPostResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersParseOperations(?Model\HelpersParseOperationsPostBody $requestBody = null, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersParseOperations($requestBody, $queryParameters), $fetch);
    }

    /**
     * Simulate the validation of a block that would contain the given operations and return the resulting fitness and context hash.
     *
     * @param array $queryParameters {
     *
     * @var string $sort
     * @var string $timestamp A date in seconds from epoch
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersPreapplyBlockPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersPreapplyBlock(?Model\HelpersPreapplyBlockPostBody $requestBody = null, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersPreapplyBlock($requestBody, $queryParameters), $fetch);
    }

    /**
     * Simulate the application of the operations with the context of the given block and return the result of each operation application.
     *
     * @param Model\NextOperation[]|null $requestBody
     * @param array                      $queryParameters {
     *
     * @var string $version Supported RPC versions are version "1" (default)
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersPreapplyOperations(?array $requestBody = null, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersPreapplyOperations($requestBody, $queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getHelpersRound(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetHelpersRound(), $fetch);
    }

    /**
     * Return the type of the given entrypoint.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersScriptsEntrypointPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsEntrypoint(?Model\HelpersScriptsEntrypointPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsEntrypoint($requestBody), $fetch);
    }

    /**
     * Return the list of entrypoints of the given script.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersScriptsEntrypointsPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsEntrypoint(?Model\HelpersScriptsEntrypointsPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsEntrypoint($requestBody), $fetch);
    }

    /**
     * Normalizes some data expression using the requested unparsing mode.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersScriptsNormalizeDataPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsNormalizeDatum(?Model\HelpersScriptsNormalizeDataPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsNormalizeDatum($requestBody), $fetch);
    }

    /**
     * Normalizes a Michelson script using the requested unparsing mode.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersScriptsNormalizeScriptPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsNormalizeScript(?Model\HelpersScriptsNormalizeScriptPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsNormalizeScript($requestBody), $fetch);
    }

    /**
     * Normalize a Michelson stack using the requested unparsing mode.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersScriptsNormalizeStackPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsNormalizeStack(?Model\HelpersScriptsNormalizeStackPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsNormalizeStack($requestBody), $fetch);
    }

    /**
     * Normalizes some Michelson type by expanding `pair a b c` as `pair a (pair b c).
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersScriptsNormalizeTypePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsNormalizeType(?Model\HelpersScriptsNormalizeTypePostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsNormalizeType($requestBody), $fetch);
    }

    /**
     * Computes the serialized version of some data expression using the same algorithm as script instruction PACK.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersScriptsPackDataPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsPackDatum(?Model\HelpersScriptsPackDataPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsPackDatum($requestBody), $fetch);
    }

    /**
     * Run a Michelson script in the current context.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersScriptsRunCodePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsRunCode(?Model\HelpersScriptsRunCodePostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsRunCode($requestBody), $fetch);
    }

    /**
     * Run a single Michelson instruction.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersScriptsRunInstructionPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsRunInstruction(?Model\HelpersScriptsRunInstructionPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsRunInstruction($requestBody), $fetch);
    }

    /**
     * Run an operation with the context of the given block and without signature checks. Return the operation application result, including the consumed gas. This RPC does not support consensus operations.
     *
     * @param array $queryParameters {
     *
     * @var string $version Supported RPC version is version '1'
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsRunOperation(?Model\HelpersScriptsRunOperationPostBody $requestBody = null, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsRunOperation($requestBody, $queryParameters), $fetch);
    }

    /**
     * Simulate a call to a michelson view.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersScriptsRunScriptViewPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsRunScriptView(?Model\HelpersScriptsRunScriptViewPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsRunScriptView($requestBody), $fetch);
    }

    /**
     * Simulate a call to a view following the TZIP-4 standard. See https://gitlab.com/tezos/tzip/-/blob/master/proposals/tzip-4/tzip-4.md#view-entrypoints.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersScriptsRunViewPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsRunView(?Model\HelpersScriptsRunViewPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsRunView($requestBody), $fetch);
    }

    /**
     * Compute the size of a script in the current context.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersScriptsScriptSizePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsScriptSize(?Model\HelpersScriptsScriptSizePostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsScriptSize($requestBody), $fetch);
    }

    /**
     * Simulate running an operation at some future moment (based on the number of blocks given in the `latency` argument), and return the operation application result. The result is the same as run_operation except for the consumed gas, which depends on the contents of the cache at that future moment. This RPC estimates future gas consumption by trying to predict the state of the cache using some heuristics.
     *
     * @param array $queryParameters {
     *
     * @var string $version Supported RPC version is version '1'
     * @var string $successor_level If true, the simulation is done on the successor level of the current context.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsSimulateOperation(?Model\HelpersScriptsSimulateOperationPostBody $requestBody = null, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsSimulateOperation($requestBody, $queryParameters), $fetch);
    }

    /**
     * Run a Michelson script in the current context, keeping a trace.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersScriptsTraceCodePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsTraceCode(?Model\HelpersScriptsTraceCodePostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsTraceCode($requestBody), $fetch);
    }

    /**
     * Typecheck a piece of code in the current context.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersScriptsTypecheckCodePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsTypecheckCode(?Model\HelpersScriptsTypecheckCodePostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsTypecheckCode($requestBody), $fetch);
    }

    /**
     * Check that some data expression is well formed and of a given type in the current context.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersScriptsTypecheckDataPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postHelpersScriptsTypecheckDatum(?Model\HelpersScriptsTypecheckDataPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostHelpersScriptsTypecheckDatum($requestBody), $fetch);
    }

    /**
     * Retrieves the level, the attestation slots and the public key hash of each delegate allowed to attest a block.
     * By default, it provides this information for the next level.
     * Parameter `level` can be used to specify the (valid) level(s) in the past or future at which the attestation rights have to be returned. Parameter `delegate` can be used to restrict the results results to the given delegates. Parameter `consensus_key` can be used to restrict the results to the given consensus_keys.
     *
     * @param array $queryParameters {
     *
     * @var string $level A level integer
     * @var string $delegate A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @var string $consensus_key A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HelpersValidatorsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getHelpersValidators(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetHelpersValidators($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getLiveBlocks(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLiveBlocks(), $fetch);
    }

    /**
     * All the metadata associated to the block.
     *
     * @param array $queryParameters {
     *
     * @var string $version Supported RPC versions are version "1" (default)
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\BlockHeaderMetadata|\Psr\Http\Message\ResponseInterface|null
     */
    public function getMetadata(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetMetadata($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getMetadataHash(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetMetadataHash(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getOperationHashes(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOperationHashes(), $fetch);
    }

    /**
     * All the operations included in `n-th` validation pass of the block.
     *
     * @param string $listOffset index `n` of the requested validation pass
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getOperationHashesByListOffset(string $listOffset, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOperationHashesByListOffset($listOffset), $fetch);
    }

    /**
     * The hash of then `m-th` operation in the `n-th` validation pass of the block.
     *
     * @param string $listOffset      index `n` of the requested validation pass
     * @param string $operationOffset index `m` of the requested operation in its validation pass
     * @param string $fetch           Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getOperationHashByListOffsetByOperationOffset(string $listOffset, string $operationOffset, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOperationHashByListOffsetByOperationOffset($listOffset, $operationOffset), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getOperationMetadataHashes(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOperationMetadataHashes(), $fetch);
    }

    /**
     * All the operation metadata included in `n-th` validation pass of the block. This is only set on blocks starting from environment V1.
     *
     * @param string $listOffset index `n` of the requested validation pass
     * @param string $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getOperationMetadataHashesByListOffset(string $listOffset, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOperationMetadataHashesByListOffset($listOffset), $fetch);
    }

    /**
     * The hash of then `m-th` operation metadata in the `n-th` validation pass of the block. This is only set on blocks starting from environment V1.
     *
     * @param string $listOffset      index `n` of the requested validation pass
     * @param string $operationOffset index `m` of the requested operation in its validation pass
     * @param string $fetch           Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getOperationMetadataHashByListOffsetByOperationOffset(string $listOffset, string $operationOffset, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOperationMetadataHashByListOffsetByOperationOffset($listOffset, $operationOffset), $fetch);
    }

    /**
     * All the operations included in the block.
     *
     * @param array $queryParameters {
     *
     * @var string $version Supported RPC versions are version "1" (default)
     * @var string $force_metadata DEPRECATED: Forces to recompute the operations metadata if it was considered as too large
     * @var string $metadata defines the way metadata are queried Specifies whether or not if the operations metadata should be returned. To get the metadata, even if it is needed to recompute them, use "always". To avoid getting the metadata, use "never". By default, the metadata will be returned depending on the node's metadata size limit policy.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getOperations(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOperations($queryParameters), $fetch);
    }

    /**
     * All the operations included in `n-th` validation pass of the block.
     *
     * @param string $listOffset      index `n` of the requested validation pass
     * @param array  $queryParameters {
     *
     * @var string $version Supported RPC versions are version "1" (default)
     * @var string $force_metadata DEPRECATED: Forces to recompute the operations metadata if it was considered as too large
     * @var string $metadata defines the way metadata are queried Specifies whether or not if the operations metadata should be returned. To get the metadata, even if it is needed to recompute them, use "always". To avoid getting the metadata, use "never". By default, the metadata will be returned depending on the node's metadata size limit policy.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getOperationsByListOffset(string $listOffset, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOperationsByListOffset($listOffset, $queryParameters), $fetch);
    }

    /**
     * The `m-th` operation in the `n-th` validation pass of the block.
     *
     * @param string $listOffset      index `n` of the requested validation pass
     * @param string $operationOffset index `m` of the requested operation in its validation pass
     * @param array  $queryParameters {
     *
     * @var string $version Supported RPC versions are version "1" (default)
     * @var string $force_metadata DEPRECATED: Forces to recompute the operations metadata if it was considered as too large
     * @var string $metadata defines the way metadata are queried Specifies whether or not if the operations metadata should be returned. To get the metadata, even if it is needed to recompute them, use "always". To avoid getting the metadata, use "never". By default, the metadata will be returned depending on the node's metadata size limit policy.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getOperationByListOffsetByOperationOffset(string $listOffset, string $operationOffset, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOperationByListOffsetByOperationOffset($listOffset, $operationOffset, $queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getOperationsMetadataHash(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOperationsMetadataHash(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ProtocolsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getProtocol(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetProtocol(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getResultingContextHash(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetResultingContextHash(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VotesBallotListGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getVotesBallotList(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVotesBallotList(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VotesBallotsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getVotesBallot(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVotesBallot(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VotesCurrentPeriodGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getVotesCurrentPeriod(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVotesCurrentPeriod(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getVotesCurrentProposal(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVotesCurrentProposal(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getVotesCurrentQuorum(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVotesCurrentQuorum(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VotesListingsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getVotesListings(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVotesListings(), $fetch);
    }

    /**
     * Number of votes casted during the current period.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getVotesProposalCountByPkh(string $pkh, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVotesProposalCountByPkh($pkh), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getVotesProposals(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVotesProposals(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VotesSuccessorPeriodGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getVotesSuccessorPeriod(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVotesSuccessorPeriod(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getVotesTotalVotingPower(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVotesTotalVotingPower(), $fetch);
    }

    public static function create($httpClient = null, array $additionalPlugins = [], array $additionalNormalizers = [])
    {
        if (null === $httpClient) {
            $httpClient = \Http\Discovery\Psr18ClientDiscovery::find();
            $plugins = [];
            if (count($additionalPlugins) > 0) {
                $plugins = array_merge($plugins, $additionalPlugins);
            }
            $httpClient = new \Http\Client\Common\PluginClient($httpClient, $plugins);
        }
        $requestFactory = \Http\Discovery\Psr17FactoryDiscovery::findRequestFactory();
        $streamFactory = \Http\Discovery\Psr17FactoryDiscovery::findStreamFactory();
        $normalizers = [new \Symfony\Component\Serializer\Normalizer\ArrayDenormalizer(), new Normalizer\JaneObjectNormalizer()];
        if (count($additionalNormalizers) > 0) {
            $normalizers = array_merge($normalizers, $additionalNormalizers);
        }
        $serializer = new \Symfony\Component\Serializer\Serializer($normalizers, [new \Symfony\Component\Serializer\Encoder\JsonEncoder(new \Symfony\Component\Serializer\Encoder\JsonEncode(), new \Symfony\Component\Serializer\Encoder\JsonDecode(['json_decode_associative' => true]))]);

        return new static($httpClient, $requestFactory, $serializer, $streamFactory);
    }
}
